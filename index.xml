<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kazuk のメモ書き</title><link>https://kazuk.github.io/kazuk.log/</link><description>Recent content on kazuk のメモ書き</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 17 Sep 2021 14:45:42 +0900</lastBuildDate><atom:link href="https://kazuk.github.io/kazuk.log/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust アプリケーションの性能管理とパフォーマンスチューニング</title><link>https://kazuk.github.io/kazuk.log/posts/rust-perf-tuning/</link><pubDate>Fri, 17 Sep 2021 14:45:42 +0900</pubDate><guid>https://kazuk.github.io/kazuk.log/posts/rust-perf-tuning/</guid><description>Rust は基本的にはネイティブなコードを吐き出すし、C/C++と同等な性能の出るプログラミング言語と言われています。
しかし、性能について全く考慮する必要の無いプログラムというのは無いですし、処理の追加や変更での性能変化特に処理性能が下がる事はパフォーマンスデグレードという事でアルゴリズムの変更時等にパフォーマンスの変化は追い続ける必要があります。
パフォーマンスが期待値まで出ていない場合にはパフォーマンスチューニングをする事になります
性能計測 性能計測と大きめの題目を上げていますが、これは本当に難しい問題を内在しています。
性能計測環境のハードウェア、ソフトウェアは適切に管理されていなければなりません。特に性能管理（パフォーマンストラッキング）をする場合にはアプリケーションの変更での性能変化を検出する必要があり、ハードウェア構成やソフトウェア構成の異なる環境での結果と比較しても意味がありません。
性能計測環境の維持管理が困難な問題の場合、別のアプローチもありえます。git 等のソース管理ツールがちゃんと利用されていれば、最新のハードウェア、ソフトウェアで過去のバージョンから現在のバージョンまで一連をビルドしてベンチマークしてみる事はできます。
そして、最近のPC(に使われているCPUやGPU)は排熱処理の問題から、短期的な性能変動がかなり大きいです。ベンチマークを繰り返し実行して安定点をさぐろうとしているうちにPCが熱をもってしまって性能だだ下がりとか、夏場は明らかにベンチ結果が低いとかあります。
性能計測をちゃんとやろうとすると、ハードウェアやソフトウェア、気温その他色々な事に気を配る必要があって大変だという事は理解してもらったと思います。その上でこの先の記述では全部無視します。
適切に管理されたパフォーマンストラッキングもアプリケーションによっては必要ですが、「開発者が開発環境内でパフォーマンス変化を確認したりそれを元に遅くなってるから改善しなきゃと気付ける」のも必要で、どちらかというと後者寄りで利用するツールその他を解説していきます。（前者を求めている人は頑張って）
ベンチマークの作成と実行 Rust のパッケージマネージャでありビルドツールであり、標準タスクランナーであり(ほんとなんでも出来るな)の cargo にはベンチマークを実行する機能があります。
cargo-bench : The Cargo Book
しかし、cargo bench で実行されるベンチマークの記述には Nightly channel が必要になるなど若干どころではない課題があります。
特にベンチマーク結果を元に性能管理をしようとした場合、 「Nightly コンパイラでのコンパイル結果を Nightly ランタイムで動かしたベンチマーク計測して意味あるの？出荷物はStableでコンパイルするんだよね？」という問題にぶつかります。
前述の cargo-bench のページでも紹介されていますが、 criterion を利用する事で cargo bench で実行可能なベンチマークを Stable channel でビルド実行する事が可能です。
また、criterion は計測するだけでなくベースラインと性能を比較する機能もある為、性能管理もある程度サポートされます。
Getting Started: Criterion.rs Documentation通りで基本的には何の問題もありません。
dev-dependencies に criterion を追加する
$ cargo add --dev criterion
benches 配下にベンチマークを作成し cargo.toml に追加する
cargo bench で実行する</description></item><item><title>RustプログラムのCoverageをGRCOVで取得する</title><link>https://kazuk.github.io/kazuk.log/posts/rust-grcov-coverage/</link><pubDate>Mon, 13 Sep 2021 09:10:15 +0900</pubDate><guid>https://kazuk.github.io/kazuk.log/posts/rust-grcov-coverage/</guid><description>rust は単体テストの実行等は cargo に統合されていて非常に扱い安いのですが、カバレッジの取得や確認は統合されていません。
また、カバレッジの取得には nightly コンパイラが必要になる等ちょっとした要件があります。
プロジェクトにカバレッジの取得を追加する度に毎度google検索していたりするので、これを一旦まとめておきます。
カバレッジの取得に必要な物 grcov
プロファイラ出力されたカバレッジ情報の集約や変換等を行います。 cargo install grcov でインストールする事ができます。
llvm-tools-preview
grcov が依存しています。 rustup component and llvm-tools-preview でインストールします。
Stable rust (rust 1.60 より stable rust でもカバレッジの採取が可能になりました。) ~~ Nightly rust ~~
プロファイラの為のコンパイルオプションは現状 Nightly rust コンパイラでのみサポートされています。
rustup toolchain install nightly でインストールします。
Nightlyコンパイラは名前の通り毎晩リリースされ「稀に壊れます」何かうまく行かない等がある場合には rustup update でより新しいバージョンを取得してくる、Nightly の最新でうまく行かない場合等は日付指定での Nightly コンパイラへ入れ替える等をしてくる必要があります。 そういう場合には Working with nightly Rust を参考にして下さい。
カバレッジ取得の流れ カバレッジの取得はカバレッジプロファイリングオプションを付けてターゲットをコンパイルする、テストを実行しカバレッジ情報を取得する。 grcov でソースとカバレッジ情報を統合する流れになります。
カバレッジプロファイル指定でのビルド プロファイリングオプションを付けてビルドするには基本的には RUSTFLAGS を指定して cargo build するだけです。nightly コンパイラを使うのを考慮すると以下になります。</description></item><item><title>DPLL SAT Solver を自作した</title><link>https://kazuk.github.io/kazuk.log/posts/dpll-sat-solver/</link><pubDate>Sun, 05 Sep 2021 10:29:37 +0900</pubDate><guid>https://kazuk.github.io/kazuk.log/posts/dpll-sat-solver/</guid><description>というわけで。（どんなわけで）
DPLL アルゴリズムを使った SAT Solver を自作した。
kazuk/pico-sat
DIMACS とかその辺のサポートをしてない非常に素朴な実装。
SAT Solver に対しての入力になる論理式をこねくり回すロジックは現状実装途中の書きかけ。
DPLL アルゴリズム 世の中のSATソルバーの殆どはこのアルゴリズムないし、その改善型を使っているらしいので利用アルゴリズムとして選定した。
DPLLアルゴリズム DPLLアルゴリズムの実装は rust で「素朴」に書くぶんには 200LoC以下に収まるサイズで実装できた。VecとHashSetにほぼほぼ必要な物はあるので組み合わせるだけである。
現状実装では再帰を使っているので問題の規模によってはスタックオーバーフローで落ちるだろうし、複数スレッド化したりメモリ利用を抑え込んだり効率的なバックトラックをしようとするとドンドンデカくなるのは容易に想像が付くのであくまで「素朴」な実装での規模感である。
特に工夫のない DPLL SAT Solver なので現状では「なんの工夫もされてないオンボロの性能」のプロファイリングリファレンスとしてしか使えないと思う。
DPLLアルゴリズムには、２点ヒューリスティックな部分があり、そこにどんな方針を立てて実装しているかは以下
分割規則の適用時における分割位置の選択
分割規則の適用時には、分割位置として選択したリテラルがすべて消えるこのため「消えるのが多い方が嬉しいはず」という事で出現回数が最も多い変数を分割位置として選定している。
分割規則で分割後に分割で利用した変数を真と仮定した枝と、偽と仮定した枝のどちらを優先して探索するか
単一の解答が欲しい solve_one では SAT / UNSATどちらにしても「小さい枝を処理した方が答えが早くでるだろう」という事で小さい枝を優先して探索するようにしている。 すべての解答が欲しい solve_all ではどっちにしても両方処理するので真、偽の順で固定している。
論理式の連言標準形への変換 SAT Solver の入力となる論理式は、連言標準形である必要があり、連言標準形は和積標準形のため、式の木構造としては以下のような構造になる必要がある。
- OR - AND - 変項 - NOT 変項 この様な論理式を利用するアプリケーションが直接作り出すのは結構厄介なのは目に見えているので、割と普通の論理式の形で入力ができるようにしたい。
現状実装途中なので、方針が変わる可能性はあるが、以下が現状の実装方針。
Not 配下の OR、Not 配下の AND のノードに対してド・モルガンの法則を適用すると OR が Not AND Not の形になり、ANDの上のNot は元々存在した Not と二重否定になり消え Not が一つ下の階層に移動する。これを繰り返し適用すると、最下層に変項ないし、Not変項が配置される。</description></item><item><title>Rust の中間言語インタープリタ MIRI による検証</title><link>https://kazuk.github.io/kazuk.log/posts/rust-miri/</link><pubDate>Fri, 20 Aug 2021 13:40:47 +0900</pubDate><guid>https://kazuk.github.io/kazuk.log/posts/rust-miri/</guid><description>Rust の中間言語は MIR と呼ばれます。
この中間言語コードを実行するインタープリタが MIRI です。
インタープリタ実行の為、多少低速ではありますが、コンパイルされたバイナリを実行する時にはできない諸々の検証が行える為、ライブラリの利用方法の誤りや、unsafe コードを含む rust コードに誤りが無いかを確認できます。unsafe コードの動作に問題が無いか確認できるという点で unsafe コードを含むコードを開発している場合には MIRI の利用は強く推奨できます。
「unsafe コード書いて MIRI 回してないってホント大丈夫？」
って言うレベルで unsafe コードを書いているなら必須です。
なので何らか重要なライブラリやフレームワークの導入時にソースを clone してきて回してみるぐらいはした方が良いかなと思います。
MIRI の導入 MIRI を導入するのは比較的簡単で nightly ツールチェインに対して miri を追加するだけでセットアップできますす。
$ rustup +nightly component add miri MIRI の実行 既存のテストを MIRI で実行するには cargo +nightly miri test で行います。
$ cargo +nightly miri test MIRI で検出したエラーへの対処 この部分が MIRI の弱さではありますが、エラーログとライブラリのドキュメントその他を熟読して何故エラーとして報告されるのかを確認するしかありません。
unsafe となっているライブラリメソッドには概ね Safety についての解説がありますので、呼び出している unsafe メソッドの Safety についての解説を確認しましょう。
とりあえずエラーを開発者に一報した上でソースとライブラリドキュメントを読み込んで開発者と一緒に問題をクリアしていけると良いですね。
自分が見つけた MIRI エラー 何か見つける毎に追記していこうと思います。</description></item><item><title>Rust で Web Front-end な WASM を作るなら Yew が良い</title><link>https://kazuk.github.io/kazuk.log/posts/yew-rs/</link><pubDate>Tue, 17 Aug 2021 12:05:47 +0900</pubDate><guid>https://kazuk.github.io/kazuk.log/posts/yew-rs/</guid><description>個人の感想ですが。
公式ドキュメント Yew APIドキュメント docs.rs:yew
ドキュメントの Introduction から Getting Started で十分に始められる様な気がします。
このページにはハマった事や調べた事とかあれば随時書こうと思います。</description></item><item><title>自己紹介のような物</title><link>https://kazuk.github.io/kazuk.log/posts/self-introduction/</link><pubDate>Tue, 17 Aug 2021 11:13:45 +0900</pubDate><guid>https://kazuk.github.io/kazuk.log/posts/self-introduction/</guid><description>晒しすぎない程度に自己紹介
1972年産まれ、もうじき50歳 職業プログラマー 現 Japan Digital Design corp site Github:org 勤務 通信や制御が大好き 中長期には rust を自分の中の主力言語にしたいのですが、現職の会社の方向性とは食い違ってるのでお誘い頂ければ考えますな状態 興味を持っているもの WASM/WASI WebRTC Embedded (趣味で RaspberryPi / PiPico をいじってます) OSS contributions OSS への貢献等、マージされた Pull-Request を随時書き込んでいきます
appache/arrow-rs(#326): allow to read non-standard CSV alog-rs/journald(#7): fix compiler warnings on rust 1.45.0 async-rs/async-attributes(#16): fix compile error with rustc 1.45.0 hyperium/http(#284): Add method_ref, uri_ref, headers_ref to request::Builder</description></item></channel></rss>